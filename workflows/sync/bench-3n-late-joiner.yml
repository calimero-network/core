# ============================================================================
# Benchmark: 3 Nodes, Late Joiner Catch-up
# ============================================================================
#
# Scenario: 
#   1. N1 and N2 create divergent state (50 keys each)
#   2. Wait for N1 and N2 to sync
#   3. N3 joins LATE and must catch up
#   4. Measure time for N3 to converge
#
# Goal: Measure catch-up time for a node joining after divergence.
#
# ============================================================================

description: "3 nodes, late joiner catch-up benchmark"
name: "Bench 3N Late Joiner"

force_pull_image: false
nuke_on_start: true
e2e_mode: true

nodes:
  chain_id: testnet-1
  count: 3
  image: ghcr.io/calimero-network/merod:edge
  prefix: b3nlj

steps:
  # ===========================================================================
  # PHASE 1: Setup (only N1 and N2 initially)
  # ===========================================================================

  - name: Install Application
    type: install_application
    node: b3nlj-1
    path: ./workflow-examples/res/kv_store.wasm
    dev: true
    outputs:
      app_id: applicationId

  - name: Create Context
    type: create_context
    node: b3nlj-1
    application_id: "{{app_id}}"
    outputs:
      context_id: contextId
      pk_node1: memberPublicKey

  - name: Create Identity N2
    type: create_identity
    node: b3nlj-2
    outputs:
      pk_node2: publicKey

  - name: Create Identity N3 (will join later)
    type: create_identity
    node: b3nlj-3
    outputs:
      pk_node3: publicKey

  - name: Invite N2
    type: invite_identity
    node: b3nlj-1
    context_id: "{{context_id}}"
    grantee_id: "{{pk_node2}}"
    granter_id: "{{pk_node1}}"
    capability: member
    outputs:
      inv2: invitation

  - name: Invite N3 (prepare invitation, but N3 won't join yet)
    type: invite_identity
    node: b3nlj-1
    context_id: "{{context_id}}"
    grantee_id: "{{pk_node3}}"
    granter_id: "{{pk_node1}}"
    capability: member
    outputs:
      inv3: invitation

  - name: N2 Joins
    type: join_context
    node: b3nlj-2
    context_id: "{{context_id}}"
    invitee_id: "{{pk_node2}}"
    invitation: "{{inv2}}"

  - name: Wait for N1-N2 mesh
    type: wait
    seconds: 20

  # ===========================================================================
  # PHASE 2: Create divergence (N1 and N2 only, N3 is not connected)
  # ===========================================================================

  - name: ">>> PHASE 2: Creating divergence on N1 and N2"
    type: wait
    seconds: 1

  - name: N1 writes 50 keys
    type: repeat
    count: 50
    steps:
      - name: "N1:n1_k{{iteration}}"
        type: call
        node: b3nlj-1
        context_id: "{{context_id}}"
        executor_public_key: "{{pk_node1}}"
        method: set
        args:
          key: "n1_k{{iteration}}"
          value: "from_n1_{{iteration}}_xxxxxxxxxxxx"

  - name: N2 writes 50 keys
    type: repeat
    count: 50
    steps:
      - name: "N2:n2_k{{iteration}}"
        type: call
        node: b3nlj-2
        context_id: "{{context_id}}"
        executor_public_key: "{{pk_node2}}"
        method: set
        args:
          key: "n2_k{{iteration}}"
          value: "from_n2_{{iteration}}_xxxxxxxxxxxx"

  # ===========================================================================
  # PHASE 3: Wait for N1-N2 to sync (N3 is still out)
  # ===========================================================================

  - name: ">>> PHASE 3: N1 and N2 syncing (N3 not connected)"
    type: wait
    seconds: 30

  # Verify N1 and N2 are in sync
  - name: "Verify N1 has N2's data"
    type: call
    node: b3nlj-1
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node1}}"
    method: get
    args:
      key: "n2_k25"
    outputs:
      n1_has_n2: result

  - name: "Verify N2 has N1's data"
    type: call
    node: b3nlj-2
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node2}}"
    method: get
    args:
      key: "n1_k25"
    outputs:
      n2_has_n1: result

  - name: Assert N1-N2 synced
    type: json_assert
    statements:
      - 'json_subset({{n1_has_n2}}, {"output": "from_n2_25_xxxxxxxxxxxx"})'
      - 'json_subset({{n2_has_n1}}, {"output": "from_n1_25_xxxxxxxxxxxx"})'

  # ===========================================================================
  # PHASE 4: N3 joins LATE (must catch up on 100 keys)
  # ===========================================================================

  - name: ">>> BENCHMARK START: N3 joins late (100 keys to catch up)"
    type: wait
    seconds: 1

  - name: N3 Joins Context (LATE JOINER)
    type: join_context
    node: b3nlj-3
    context_id: "{{context_id}}"
    invitee_id: "{{pk_node3}}"
    invitation: "{{inv3}}"

  # ===========================================================================
  # PHASE 5: Wait for N3 to catch up
  # ===========================================================================

  - name: ">>> CATCH-UP PHASE: N3 syncing 100 keys"
    type: wait
    seconds: 45

  # ===========================================================================
  # PHASE 6: Verify N3 has ALL data
  # ===========================================================================

  - name: "N3 has N1:k1"
    type: call
    node: b3nlj-3
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node3}}"
    method: get
    args:
      key: "n1_k1"
    outputs:
      n3_n1_k1: result

  - name: "N3 has N1:k50"
    type: call
    node: b3nlj-3
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node3}}"
    method: get
    args:
      key: "n1_k50"
    outputs:
      n3_n1_k50: result

  - name: "N3 has N2:k1"
    type: call
    node: b3nlj-3
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node3}}"
    method: get
    args:
      key: "n2_k1"
    outputs:
      n3_n2_k1: result

  - name: "N3 has N2:k50"
    type: call
    node: b3nlj-3
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node3}}"
    method: get
    args:
      key: "n2_k50"
    outputs:
      n3_n2_k50: result

  # ===========================================================================
  # PHASE 7: Assert N3 caught up
  # ===========================================================================

  - name: Assert N3 caught up completely
    type: json_assert
    statements:
      - 'json_subset({{n3_n1_k1}}, {"output": "from_n1_1_xxxxxxxxxxxx"})'
      - 'json_subset({{n3_n1_k50}}, {"output": "from_n1_50_xxxxxxxxxxxx"})'
      - 'json_subset({{n3_n2_k1}}, {"output": "from_n2_1_xxxxxxxxxxxx"})'
      - 'json_subset({{n3_n2_k50}}, {"output": "from_n2_50_xxxxxxxxxxxx"})'

  - name: ">>> BENCHMARK COMPLETE"
    type: assert
    statements:
      - statement: "is_set({{n3_n1_k1}})"
        message: "LATE-JOINER: N3 caught up with 100 keys from N1+N2"

stop_all_nodes: true
restart: false
wait_timeout: 180
