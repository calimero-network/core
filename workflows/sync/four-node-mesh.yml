# ============================================================================
# Four-Node Mesh Sync Test
# ============================================================================
#
# This test creates a four-node mesh topology where all nodes write
# concurrently, demonstrating:
#   - Multi-hop gossip propagation (A→B→C→D)
#   - Convergence with multiple concurrent writers
#   - Protocol handling under higher network complexity
#
# Topology:
#   Node1 ←──────→ Node2
#     ↕              ↕
#   Node4 ←──────→ Node3
#
# Each node writes 15 unique keys (60 total)
# All nodes should converge to 60 keys
#
# ============================================================================

description: Four-node mesh topology with concurrent writes
name: Four Node Mesh Sync Test

force_pull_image: false
nuke_on_start: true
e2e_mode: true

nodes:
  chain_id: testnet-1
  count: 4
  image: ghcr.io/calimero-network/merod:edge
  prefix: mesh-node

steps:
  # ===========================================================================
  # PHASE 1: Setup four-node mesh
  # ===========================================================================

  - name: Install Application on Node 1
    type: install_application
    node: mesh-node-1
    path: ./workflow-examples/res/kv_store.wasm
    dev: true
    outputs:
      app_id: applicationId

  - name: Create Context on Node 1
    type: create_context
    node: mesh-node-1
    application_id: "{{app_id}}"
    outputs:
      context_id: contextId
      pk_node1: memberPublicKey

  # Create identities for other nodes
  - name: Create Identity on Node 2
    type: create_identity
    node: mesh-node-2
    outputs:
      pk_node2: publicKey

  - name: Create Identity on Node 3
    type: create_identity
    node: mesh-node-3
    outputs:
      pk_node3: publicKey

  - name: Create Identity on Node 4
    type: create_identity
    node: mesh-node-4
    outputs:
      pk_node4: publicKey

  # Invite all nodes
  - name: Invite Node 2
    type: invite_identity
    node: mesh-node-1
    context_id: "{{context_id}}"
    grantee_id: "{{pk_node2}}"
    granter_id: "{{pk_node1}}"
    capability: member
    outputs:
      invitation_node2: invitation

  - name: Invite Node 3
    type: invite_identity
    node: mesh-node-1
    context_id: "{{context_id}}"
    grantee_id: "{{pk_node3}}"
    granter_id: "{{pk_node1}}"
    capability: member
    outputs:
      invitation_node3: invitation

  - name: Invite Node 4
    type: invite_identity
    node: mesh-node-1
    context_id: "{{context_id}}"
    grantee_id: "{{pk_node4}}"
    granter_id: "{{pk_node1}}"
    capability: member
    outputs:
      invitation_node4: invitation

  # Join all nodes
  - name: Node 2 Joins
    type: join_context
    node: mesh-node-2
    context_id: "{{context_id}}"
    invitee_id: "{{pk_node2}}"
    invitation: "{{invitation_node2}}"

  - name: Node 3 Joins
    type: join_context
    node: mesh-node-3
    context_id: "{{context_id}}"
    invitee_id: "{{pk_node3}}"
    invitation: "{{invitation_node3}}"

  - name: Node 4 Joins
    type: join_context
    node: mesh-node-4
    context_id: "{{context_id}}"
    invitee_id: "{{pk_node4}}"
    invitation: "{{invitation_node4}}"

  - name: Wait for Mesh Formation
    type: wait
    seconds: 15

  # ===========================================================================
  # PHASE 2: All nodes write concurrently (15 keys each = 60 total)
  # ===========================================================================

  - name: "[Node 1] Write 15 keys"
    type: repeat
    count: 15
    steps:
      - name: "Node 1 writes mesh1_{{iteration}}"
        type: call
        node: mesh-node-1
        context_id: "{{context_id}}"
        executor_public_key: "{{pk_node1}}"
        method: set
        args:
          key: "mesh1_key_{{iteration}}"
          value: "value_from_node1_{{iteration}}"

  - name: "[Node 2] Write 15 keys"
    type: repeat
    count: 15
    steps:
      - name: "Node 2 writes mesh2_{{iteration}}"
        type: call
        node: mesh-node-2
        context_id: "{{context_id}}"
        executor_public_key: "{{pk_node2}}"
        method: set
        args:
          key: "mesh2_key_{{iteration}}"
          value: "value_from_node2_{{iteration}}"

  - name: "[Node 3] Write 15 keys"
    type: repeat
    count: 15
    steps:
      - name: "Node 3 writes mesh3_{{iteration}}"
        type: call
        node: mesh-node-3
        context_id: "{{context_id}}"
        executor_public_key: "{{pk_node3}}"
        method: set
        args:
          key: "mesh3_key_{{iteration}}"
          value: "value_from_node3_{{iteration}}"

  - name: "[Node 4] Write 15 keys"
    type: repeat
    count: 15
    steps:
      - name: "Node 4 writes mesh4_{{iteration}}"
        type: call
        node: mesh-node-4
        context_id: "{{context_id}}"
        executor_public_key: "{{pk_node4}}"
        method: set
        args:
          key: "mesh4_key_{{iteration}}"
          value: "value_from_node4_{{iteration}}"

  # ===========================================================================
  # PHASE 3: Wait for mesh convergence
  # ===========================================================================

  - name: Wait for Mesh Convergence
    type: wait
    seconds: 90

  # ===========================================================================
  # PHASE 4: Verify all nodes have all data
  # ===========================================================================

  # Verify cross-node data presence
  - name: "[Verify] Node 1 has Node 4's key"
    type: call
    node: mesh-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node1}}"
    method: get
    args:
      key: "mesh4_key_10"
    outputs:
      n1_has_n4: result

  - name: "[Verify] Node 2 has Node 3's key"
    type: call
    node: mesh-node-2
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node2}}"
    method: get
    args:
      key: "mesh3_key_10"
    outputs:
      n2_has_n3: result

  - name: "[Verify] Node 3 has Node 1's key"
    type: call
    node: mesh-node-3
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node3}}"
    method: get
    args:
      key: "mesh1_key_10"
    outputs:
      n3_has_n1: result

  - name: "[Verify] Node 4 has Node 2's key"
    type: call
    node: mesh-node-4
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node4}}"
    method: get
    args:
      key: "mesh2_key_10"
    outputs:
      n4_has_n2: result

  # Get total counts
  - name: "[Verify] Node 1 total count"
    type: call
    node: mesh-node-1
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node1}}"
    method: len
    outputs:
      count_node1: result

  - name: "[Verify] Node 2 total count"
    type: call
    node: mesh-node-2
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node2}}"
    method: len
    outputs:
      count_node2: result

  - name: "[Verify] Node 3 total count"
    type: call
    node: mesh-node-3
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node3}}"
    method: len
    outputs:
      count_node3: result

  - name: "[Verify] Node 4 total count"
    type: call
    node: mesh-node-4
    context_id: "{{context_id}}"
    executor_public_key: "{{pk_node4}}"
    method: len
    outputs:
      count_node4: result

  # ===========================================================================
  # PHASE 5: Assert convergence
  # ===========================================================================

  - name: Assert Cross-Node Data Presence
    type: json_assert
    statements:
      - 'json_subset({{n1_has_n4}}, {"output": "value_from_node4_10"})'
      - 'json_subset({{n2_has_n3}}, {"output": "value_from_node3_10"})'
      - 'json_subset({{n3_has_n1}}, {"output": "value_from_node1_10"})'
      - 'json_subset({{n4_has_n2}}, {"output": "value_from_node2_10"})'

  - name: Assert Full Convergence (60 keys each)
    type: json_assert
    statements:
      - 'json_subset({{count_node1}}, {"output": 60})'
      - 'json_subset({{count_node2}}, {"output": 60})'
      - 'json_subset({{count_node3}}, {"output": 60})'
      - 'json_subset({{count_node4}}, {"output": 60})'

  - name: Final Summary
    type: assert
    statements:
      - statement: "is_set({{count_node4}})"
        message: "Four-node mesh sync completed - all 4 nodes converged to 60 keys"

stop_all_nodes: true
restart: false
wait_timeout: 300
