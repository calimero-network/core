use std::fs;
use std::path::Path;

use calimero_wasm_abi::schema::Manifest;
use serde_json::Value;

/// Find and read abi.json file based on WASM file path
/// Looks in apps/{app_name}/res/abi.json relative to workspace root
fn find_and_read_abi_json(wasm_file: &Path) -> eyre::Result<String> {
    let wasm_dir = wasm_file
        .parent()
        .ok_or_else(|| eyre::eyre!("WASM file has no parent directory"))?;

    // Extract app name from WASM filename (e.g., "abi_conformance.wasm" -> "abi_conformance")
    let wasm_stem = wasm_file
        .file_stem()
        .and_then(|s| s.to_str())
        .ok_or_else(|| eyre::eyre!("WASM file has no valid filename"))?;

    // Find workspace root by looking for Cargo.toml going up from WASM file
    let mut workspace_root = wasm_dir.to_path_buf();
    let mut found_workspace = false;
    for _ in 0..10 {
        // Limit search depth
        if workspace_root.join("Cargo.toml").exists() {
            found_workspace = true;
            break;
        }
        if let Some(parent) = workspace_root.parent() {
            workspace_root = parent.to_path_buf();
        } else {
            break;
        }
    }

    let mut abi_json_paths = Vec::new();

    // If we found workspace root, look in apps/{app_name}/res/abi.json
    if found_workspace {
        abi_json_paths.push(
            workspace_root
                .join("apps")
                .join(wasm_stem)
                .join("res/abi.json"),
        );
        // Also try with underscores converted to hyphens (e.g., "kv-store" vs "kv_store")
        let app_name_hyphenated = wasm_stem.replace('_', "-");
        if app_name_hyphenated != wasm_stem {
            abi_json_paths.push(
                workspace_root
                    .join("apps")
                    .join(&app_name_hyphenated)
                    .join("res/abi.json"),
            );
        }
    }

    // Also check relative to WASM file location (for backwards compatibility)
    abi_json_paths.extend(vec![
        wasm_dir.join("abi.json"),
        wasm_dir.join("res/abi.json"),
        wasm_dir
            .parent()
            .map(|p| p.join("res/abi.json"))
            .unwrap_or_else(|| wasm_dir.join("abi.json")),
    ]);

    for path in &abi_json_paths {
        if path.exists() {
            let json_str = fs::read_to_string(path)?;
            // Validate JSON
            drop(serde_json::from_str::<serde_json::Value>(&json_str)?);
            return Ok(json_str);
        }
    }

    eyre::bail!(
        "No abi.json file found. Checked: {}",
        abi_json_paths
            .iter()
            .map(|p| p.display().to_string())
            .collect::<Vec<_>>()
            .join(", ")
    );
}

/// Extract the state schema (state root type and all its dependencies) from a WASM file
/// Reads from abi.json file generated by build.rs
pub fn extract_state_schema(wasm_file: &Path, output: Option<&Path>) -> eyre::Result<()> {
    // Read abi.json file
    let abi_json = find_and_read_abi_json(wasm_file)?;

    // Parse the ABI manifest
    let manifest: Manifest = serde_json::from_str(&abi_json)
        .map_err(|e| eyre::eyre!("Failed to parse ABI manifest: {}", e))?;

    // Extract state schema using the Manifest method
    let mut state_schema_manifest = manifest
        .extract_state_schema()
        .map_err(|e| eyre::eyre!("Failed to extract state schema: {}", e))?;

    // Set schema_version to match build.rs format
    state_schema_manifest.schema_version = "wasm-abi/1".to_owned();

    // Serialize the entire Manifest (same format as build-time emission)
    let schema_json = serde_json::to_string_pretty(&state_schema_manifest)
        .map_err(|e| eyre::eyre!("Failed to serialize state schema: {}", e))?;

    // Determine output path
    let output_path = output.map_or_else(
        || {
            let mut path = wasm_file.to_path_buf();
            let _ = path.set_extension("state-schema.json");
            path
        },
        Path::to_path_buf,
    );

    // Write the state schema JSON
    fs::write(&output_path, schema_json)?;

    println!(
        "State schema extracted successfully to: {}",
        output_path.display()
    );
    if let Some(ref root) = state_schema_manifest.state_root {
        println!("State root: {root}");
    }
    println!(
        "Found {} type definitions",
        state_schema_manifest.types.len()
    );

    Ok(())
}

/// Extract just the types schema from a WASM file
/// Reads from abi.json file generated by build.rs
pub fn extract_types_schema(wasm_file: &Path, output: Option<&Path>) -> eyre::Result<()> {
    // Read abi.json file
    let abi_json = find_and_read_abi_json(wasm_file)?;

    // Parse the ABI JSON
    let abi_value: Value =
        serde_json::from_str(&abi_json).map_err(|e| eyre::eyre!("Invalid ABI JSON: {}", e))?;

    // Extract just the types field
    let types_schema = abi_value
        .get("types")
        .ok_or_else(|| eyre::eyre!("ABI JSON missing 'types' field"))?;

    // Serialize the types schema with pretty printing
    let types_json = serde_json::to_string_pretty(types_schema)
        .map_err(|e| eyre::eyre!("Failed to serialize types schema: {}", e))?;

    // Determine output path
    let output_path = output.map_or_else(
        || {
            let mut path = wasm_file.to_path_buf();
            let _ = path.set_extension("types.json");
            path
        },
        Path::to_path_buf,
    );

    // Write the types schema JSON
    fs::write(&output_path, types_json)?;

    // Count the number of types
    let type_count = if let Value::Object(types_map) = types_schema {
        types_map.len()
    } else {
        0
    };

    println!(
        "Types schema extracted successfully to: {}",
        output_path.display()
    );
    println!("Found {type_count} type definitions");

    Ok(())
}

/// Extract ABI from a WASM file
/// Reads from abi.json file generated by build.rs
/// Note: The verify parameter is kept for API compatibility but is no longer used
/// since ABI is no longer embedded in WASM files
pub fn extract_abi(wasm_file: &Path, output: Option<&Path>, _verify: bool) -> eyre::Result<()> {
    // Read abi.json file
    let abi_json = find_and_read_abi_json(wasm_file)?;

    // Determine output path
    let output_path = output.map_or_else(
        || {
            let mut path = wasm_file.to_path_buf();
            let _ = path.set_extension("abi.json");
            path
        },
        Path::to_path_buf,
    );

    // Write the ABI JSON
    fs::write(&output_path, abi_json)?;

    println!("ABI extracted successfully to: {}", output_path.display());

    Ok(())
}
