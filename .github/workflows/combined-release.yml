name: Combined Release & Docker Build

on:
  workflow_dispatch:
    inputs:
      test_mode:
        description: 'Run in test mode (builds everything without releasing)'
        type: boolean
        default: false
  push:
    branches:
      - master
    paths:
      - Cargo.toml
      - Cargo.lock
      - 'crates/**'
      - 'core/Dockerfile'
      - '.github/workflows/combined-release.yml'
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - master
    paths:
      - Cargo.toml
      - Cargo.lock
      - 'crates/**'
      - 'core/Dockerfile'
      - '.github/workflows/combined-release.yml'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  prepare:
    name: Prepare
    runs-on: ubuntu-latest
    outputs:
      binary_matrix: ${{ steps.setup_matrix.outputs.binary_matrix }}
      version: ${{ steps.version_info.outputs.version }}
      release_required: ${{ steps.version_info.outputs.release_required }}
      build_required: ${{ steps.version_info.outputs.build_required }}
      target_commit: ${{ steps.version_info.outputs.target_commit }}
      prerelease: ${{ steps.version_info.outputs.prerelease }}
      overwrite_release: ${{ steps.version_info.outputs.overwrite_release }}
      docker_build_required: ${{ steps.version_info.outputs.docker_build_required }}
      docker_merod_tags: ${{ steps.docker_metadata.outputs.merod_tags }}
      docker_meroctl_tags: ${{ steps.docker_metadata.outputs.meroctl_tags }}
      docker_merod_labels: ${{ steps.docker_metadata.outputs.merod_labels }}
      docker_meroctl_labels: ${{ steps.docker_metadata.outputs.meroctl_labels }}
      shared_cargo_registry_key: ${{ steps.cache_keys.outputs.shared_cargo_registry_key }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup matrix
        id: setup_matrix
        run: |
          echo 'binary_matrix=["merod", "meroctl"]' >> "$GITHUB_OUTPUT"

      - name: Get version info
        id: version_info
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          TEST_MODE: ${{ github.event.inputs.test_mode == 'true' }}
        run: |
          echo "Validating binary versions"

          # Default values for testing
          if [ "$TEST_MODE" == "true" ]; then
            echo "TEST MODE ENABLED - Will build everything without releasing"
            echo "build_required=true" >> $GITHUB_OUTPUT
            echo "docker_build_required=true" >> $GITHUB_OUTPUT
            echo "release_required=false" >> $GITHUB_OUTPUT
            echo "target_commit=${{ github.sha }}" >> $GITHUB_OUTPUT
            echo "prerelease=true" >> $GITHUB_OUTPUT
            echo "overwrite_release=false" >> $GITHUB_OUTPUT
            echo "version=test-$(date +%Y%m%d%H%M%S)" >> $GITHUB_OUTPUT
            exit 0
          fi

          version_candidate=""
          for binary in $(echo '${{ steps.setup_matrix.outputs.binary_matrix }}' | jq -r '.[]'); do
            binary_version=$(cargo metadata --format-version 1 --no-deps | jq -r --arg binary "$binary" '.packages[] | select(.name == $binary) | .version')
            echo "  binary: $binary, version: $binary_version"

            if [ -z "$version_candidate" ]; then
              version_candidate="$binary_version"
            elif [ "$version_candidate" != "$binary_version" ]; then
              echo "Version mismatch between binaries"
              echo "Make sure all binaries have the same version"
              echo "All binaries: '${{ steps.setup_matrix.outputs.binary_matrix }}'"
              exit 1
            fi
          done
          echo "Valid version candidate: $version_candidate"

          echo "target_commit=${{ github.sha }}" >> $GITHUB_OUTPUT
          
          # Determine if we need to build binaries and Docker images
          if [ "${{ github.ref }}" == "refs/heads/master" ]; then
            # Master branch settings
            version="$version_candidate"
            
            if gh release view "$version" --repo ${{ github.repository }} >/dev/null 2>&1; then
              echo "Master release for this version already exists"
              echo "release_required=false" >> $GITHUB_OUTPUT
            else
              echo "New master release required"
              echo "release_required=true" >> $GITHUB_OUTPUT
            fi
            
            echo "build_required=true" >> $GITHUB_OUTPUT
            echo "docker_build_required=true" >> $GITHUB_OUTPUT
            echo "prerelease=false" >> $GITHUB_OUTPUT
            echo "overwrite_release=false" >> $GITHUB_OUTPUT
            
          elif [ "${{ github.event_name }}" == "pull_request" ] && [[ "${{ github.head_ref }}" == release/* ]]; then
            # Release PR settings
            version="prerelease-${{ github.event.number }}"
            
            echo "build_required=true" >> $GITHUB_OUTPUT
            echo "docker_build_required=true" >> $GITHUB_OUTPUT
            echo "release_required=true" >> $GITHUB_OUTPUT
            echo "prerelease=true" >> $GITHUB_OUTPUT
            echo "overwrite_release=true" >> $GITHUB_OUTPUT
            
          elif [[ "${{ github.ref }}" == refs/heads/feat__* ]]; then
            # Feature branch settings
            branch_name=$(echo "${{ github.ref }}" | sed 's|refs/heads/||')
            version="dev-${branch_name}"
            
            echo "build_required=false" >> $GITHUB_OUTPUT
            echo "docker_build_required=true" >> $GITHUB_OUTPUT
            echo "release_required=false" >> $GITHUB_OUTPUT
            echo "prerelease=true" >> $GITHUB_OUTPUT
            
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            # PR settings
            version="pr-${{ github.event.number }}"
            
            echo "build_required=true" >> $GITHUB_OUTPUT 
            echo "docker_build_required=true" >> $GITHUB_OUTPUT
            echo "release_required=false" >> $GITHUB_OUTPUT
            echo "prerelease=true" >> $GITHUB_OUTPUT
            
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual workflow dispatch settings
            version="$version_candidate"
            
            echo "build_required=true" >> $GITHUB_OUTPUT
            echo "docker_build_required=true" >> $GITHUB_OUTPUT
            echo "release_required=true" >> $GITHUB_OUTPUT
            echo "prerelease=false" >> $GITHUB_OUTPUT
            echo "overwrite_release=true" >> $GITHUB_OUTPUT
            
          else
            # Other branches/events settings
            version="dev-$(echo ${{ github.ref }} | sed 's|refs/heads/||')"
            
            echo "build_required=false" >> $GITHUB_OUTPUT
            echo "docker_build_required=false" >> $GITHUB_OUTPUT
            echo "release_required=false" >> $GITHUB_OUTPUT
          fi
          
          echo "version=$version" >> $GITHUB_OUTPUT

      - name: Docker image metadata preparation
        id: docker_metadata
        if: steps.version_info.outputs.docker_build_required == 'true' || github.event.inputs.test_mode == 'true'
        run: |
          VERSION="${{ steps.version_info.outputs.version }}"
          IS_MASTER="${{ github.ref == 'refs/heads/master' }}"
          
          # For test mode, use a special tag
          if [ "${{ github.event.inputs.test_mode }}" == "true" ]; then
            VERSION="${VERSION}"
            # Only push to test tags in test mode
            MEROD_TAGS="ghcr.io/${{ github.repository_owner }}/merod:$VERSION"
            MEROCTL_TAGS="ghcr.io/${{ github.repository_owner }}/meroctl:$VERSION"
          else
            # Define tags for both images
            MEROD_TAGS="ghcr.io/${{ github.repository_owner }}/merod:$VERSION"
            MEROCTL_TAGS="ghcr.io/${{ github.repository_owner }}/meroctl:$VERSION"
            
            # Add latest tag for master branch
            if [ "$IS_MASTER" == "true" ]; then
              MEROD_TAGS="$MEROD_TAGS,ghcr.io/${{ github.repository_owner }}/merod:latest"
              MEROCTL_TAGS="$MEROCTL_TAGS,ghcr.io/${{ github.repository_owner }}/meroctl:latest"
            fi
          fi
          
          # Define labels for both images
          COMMON_LABELS="{\"org.opencontainers.image.source\":\"https://github.com/${{ github.repository }}\",\"org.opencontainers.image.licenses\":\"MIT\"}"
          MEROD_LABELS="$COMMON_LABELS,{\"org.opencontainers.image.description\":\"Merod container image\"}"
          MEROCTL_LABELS="$COMMON_LABELS,{\"org.opencontainers.image.description\":\"Meroctl container image\"}"
          
          echo "merod_tags=$MEROD_TAGS" >> $GITHUB_OUTPUT
          echo "meroctl_tags=$MEROCTL_TAGS" >> $GITHUB_OUTPUT
          echo "merod_labels=$MEROD_LABELS" >> $GITHUB_OUTPUT
          echo "meroctl_labels=$MEROCTL_LABELS" >> $GITHUB_OUTPUT

      - name: Generate cache keys
        id: cache_keys
        run: |
          # Generate a hash of Cargo.lock for consistent caching
          CARGO_LOCK_HASH=$(sha256sum Cargo.lock | cut -d ' ' -f 1)
          echo "shared_cargo_registry_key=cargo-registry-$CARGO_LOCK_HASH" >> $GITHUB_OUTPUT

  build-binaries-linux:
    name: Build Linux Binaries
    if: needs.prepare.outputs.build_required == 'true' || github.event.inputs.test_mode == 'true'
    runs-on: ubuntu-latest
    needs: prepare
    outputs:
      x86_64_linux_build_complete: true
      aarch64_linux_build_complete: true
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true

      - name: Add targets
        run: |
          rustup target add x86_64-unknown-linux-gnu
          rustup target add aarch64-unknown-linux-gnu

      - name: Cargo registry cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ needs.prepare.outputs.shared_cargo_registry_key }}
          restore-keys: |
            cargo-registry-

      - name: Cargo build cache x86_64
        uses: actions/cache@v4
        with:
          path: target/x86_64-unknown-linux-gnu
          key: cargo-build-x86_64-linux-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            cargo-build-x86_64-linux-

      - name: Cargo build cache aarch64
        uses: actions/cache@v4
        with:
          path: target/aarch64-unknown-linux-gnu
          key: cargo-build-aarch64-linux-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            cargo-build-aarch64-linux-

      - name: Install dependencies for cross-compilation
        run: |
          sudo apt-get update
          sudo apt-get install -y \
          gcc-aarch64-linux-gnu g++-aarch64-linux-gnu \
          libstdc++-11-dev-arm64-cross \
          zlib1g-dev \
          libsnappy-dev \
          libbz2-dev \
          liblz4-dev \
          libzstd-dev \
          clang \
          libc6-dev-arm64-cross

      - name: Download and set up OpenSSL for cross-compilation
        run: |
          wget https://www.openssl.org/source/openssl-1.1.1g.tar.gz
          tar -xzf openssl-1.1.1g.tar.gz
          cd openssl-1.1.1g
          # More restrictive C99 flags and additional compiler options
          export CROSS_COMPILE=""  # Clear CROSS_COMPILE to prevent double prefix
          export CC="aarch64-linux-gnu-gcc"
          export CXX="aarch64-linux-gnu-g++"
          export CFLAGS="-std=gnu99 -O2 -fPIC -D_GNU_SOURCE -I/usr/aarch64-linux-gnu/include"
          export LDFLAGS="-L/usr/aarch64-linux-gnu/lib"
          ./Configure linux-aarch64 --prefix=$HOME/openssl-aarch64 \
            no-asm \
            no-shared \
            no-async \
            no-engine \
            no-dso \
            no-deprecated
          make -j$(nproc) CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS"
          make install_sw
          cd ..
          echo "OPENSSL_DIR=$HOME/openssl-aarch64" >> $GITHUB_ENV
          echo "OPENSSL_LIB_DIR=$HOME/openssl-aarch64/lib" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=$HOME/openssl-aarch64/include" >> $GITHUB_ENV
          echo "PKG_CONFIG_PATH=$HOME/openssl-aarch64/lib/pkgconfig" >> $GITHUB_ENV
          echo "PKG_CONFIG_ALLOW_CROSS=1" >> $GITHUB_ENV
          echo "PKG_CONFIG_SYSROOT_DIR=/" >> $GITHUB_ENV
          echo "OPENSSL_STATIC=1" >> $GITHUB_ENV

      - name: Build x86_64 binaries
        run: |
          echo "Building x86_64-unknown-linux-gnu binaries"
          binaries=$(echo '${{ needs.prepare.outputs.binary_matrix }}' | jq -r 'join(" ") | split(" ") | map("-p " + .) | join(" ")')
          cargo build $binaries --release --target x86_64-unknown-linux-gnu

      - name: Build aarch64 binaries
        env:
          CC_aarch64_unknown_linux_gnu: aarch64-linux-gnu-gcc
          CXX_aarch64_unknown_linux_gnu: aarch64-linux-gnu-g++
          CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER: aarch64-linux-gnu-gcc
          OPENSSL_DIR: ${{ env.OPENSSL_DIR }}
          OPENSSL_LIB_DIR: ${{ env.OPENSSL_LIB_DIR }}
          OPENSSL_INCLUDE_DIR: ${{ env.OPENSSL_INCLUDE_DIR }}
          PKG_CONFIG_PATH: ${{ env.PKG_CONFIG_PATH }}
          PKG_CONFIG_ALLOW_CROSS: ${{ env.PKG_CONFIG_ALLOW_CROSS }}
          PKG_CONFIG_SYSROOT_DIR: ${{ env.PKG_CONFIG_SYSROOT_DIR }}
          OPENSSL_STATIC: ${{ env.OPENSSL_STATIC }}
        run: |
          echo "Building aarch64-unknown-linux-gnu binaries"
          binaries=$(echo '${{ needs.prepare.outputs.binary_matrix }}' | jq -r 'join(" ") | split(" ") | map("-p " + .) | join(" ")')
          cargo build $binaries --release --target aarch64-unknown-linux-gnu

      - name: Compress artifacts using gzip
        run: |
          mkdir -p artifacts
          echo '${{ needs.prepare.outputs.binary_matrix }}' | jq -r '.[]' | while read binary; do
            tar -czf artifacts/"$binary"_x86_64-unknown-linux-gnu.tar.gz -C target/x86_64-unknown-linux-gnu/release "$binary"
            tar -czf artifacts/"$binary"_aarch64-unknown-linux-gnu.tar.gz -C target/aarch64-unknown-linux-gnu/release "$binary"
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-linux
          path: artifacts/*
          retention-days: 2

  build-binaries-macos:
    name: Build macOS Binaries
    if: needs.prepare.outputs.build_required == 'true' || github.event.inputs.test_mode == 'true'
    strategy:
      matrix:
        target: [x86_64-apple-darwin, aarch64-apple-darwin]
    runs-on: macos-latest
    needs: prepare

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install rustup and Rust toolchain
        run: |
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
          source $HOME/.cargo/env
          rustup toolchain install stable
          rustup default stable

      - name: Add target
        run: rustup target add ${{ matrix.target }}

      - name: Cargo registry cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ needs.prepare.outputs.shared_cargo_registry_key }}
          restore-keys: |
            cargo-registry-

      - name: Cargo build cache
        uses: actions/cache@v4
        with:
          path: target/${{ matrix.target }}
          key: cargo-build-${{ matrix.target }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            cargo-build-${{ matrix.target }}-

      - name: Build binaries
        run: |
          binaries=$(echo '${{ needs.prepare.outputs.binary_matrix }}' | jq -r 'join(" ") | split(" ") | map("-p " + .) | join(" ")')
          cargo build $binaries --release --target ${{ matrix.target }}

      - name: Compress artifacts using gzip
        run: |
          mkdir -p artifacts
          echo '${{ needs.prepare.outputs.binary_matrix }}' | jq -r '.[]' | while read binary; do
            tar -czf artifacts/"$binary"_${{ matrix.target }}.tar.gz -C target/${{ matrix.target }}/release "$binary"
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-${{ matrix.target }}
          path: artifacts/*
          retention-days: 2

  build-docker:
    name: Build Docker Images
    needs: [prepare, build-binaries-linux]
    if: needs.prepare.outputs.docker_build_required == 'true' || github.event.inputs.test_mode == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 120
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        image: [merod, meroctl]
      fail-fast: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
      
      - name: Add targets
        run: |
          rustup target add x86_64-unknown-linux-gnu
          rustup target add aarch64-unknown-linux-gnu

      - name: Restore cargo registry cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ needs.prepare.outputs.shared_cargo_registry_key }}

      - name: Restore cargo build cache x86_64
        uses: actions/cache@v4
        with:
          path: target/x86_64-unknown-linux-gnu
          key: cargo-build-x86_64-linux-${{ hashFiles('**/Cargo.lock') }}

      - name: Restore cargo build cache aarch64
        uses: actions/cache@v4
        with:
          path: target/aarch64-unknown-linux-gnu
          key: cargo-build-aarch64-linux-${{ hashFiles('**/Cargo.lock') }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
            network=host
      
      # Only push to registry if not in test mode
      - name: Log in to GitHub Container Registry
        if: github.event.inputs.test_mode != 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Prepare Docker context with pre-built binaries
        run: |
          mkdir -p .docker-context-${{ matrix.image }}
          cp -R . .docker-context-${{ matrix.image }}/
          mkdir -p .docker-context-${{ matrix.image }}/prebuild/linux/amd64
          mkdir -p .docker-context-${{ matrix.image }}/prebuild/linux/arm64
          cp target/x86_64-unknown-linux-gnu/release/${{ matrix.image }} .docker-context-${{ matrix.image }}/prebuild/linux/amd64/
          cp target/aarch64-unknown-linux-gnu/release/${{ matrix.image }} .docker-context-${{ matrix.image }}/prebuild/linux/arm64/
          
          # Create a custom Dockerfile that uses pre-built binaries
          cat << EOF > .docker-context-${{ matrix.image }}/Dockerfile.prebuild
          # syntax=docker/dockerfile:1
          FROM debian:bookworm-slim AS ${{ matrix.image }}
          
          # Add labels for container metadata
          LABEL org.opencontainers.image.description="${{ matrix.image == 'merod' && 'Merod daemon' || 'Meroctl - Control tool for Merod daemon' }}"
          LABEL org.opencontainers.image.licenses="MIT"
          
          # Install only the essential runtime dependencies
          RUN apt-get update && apt-get install -y \\
              libssl3 \\
              ca-certificates \\
              && rm -rf /var/lib/apt/lists/*
          
          # Create a non-privileged user for running the app
          ARG UID=10001
          RUN adduser \\
              --disabled-password \\
              --gecos "" \\
              --home "/nonexistent" \\
              --shell "/sbin/nologin" \\
              --no-create-home \\
              --uid "\${UID}" \\
              appuser
          
          # Set the working directory
          WORKDIR /${{ matrix.image == 'merod' && 'data' || 'app' }}
          RUN chown appuser:appuser /${{ matrix.image == 'merod' && 'data' || 'app' }}
          
          # Copy the pre-built binary for the appropriate architecture
          ARG TARGETARCH
          COPY prebuild/linux/\${TARGETARCH}/${{ matrix.image }} /usr/local/bin/${{ matrix.image }}
          RUN chmod +x /usr/local/bin/${{ matrix.image }}
          
          # Change to non-root user
          USER appuser
          
          # Set the entrypoint
          ENTRYPOINT ["${{ matrix.image }}"]
          CMD ["--help"]
          EOF

      - name: Build and push ${{ matrix.image }} image with pre-built binaries
        uses: docker/build-push-action@v5
        with:
          context: .docker-context-${{ matrix.image }}
          file: .docker-context-${{ matrix.image }}/Dockerfile.prebuild
          # Only push if not in test mode
          push: ${{ github.event.inputs.test_mode != 'true' }}
          # Use only amd64 for test mode to save time
          platforms: ${{ github.event.inputs.test_mode == 'true' && 'linux/amd64' || 'linux/amd64,linux/arm64' }}
          tags: ${{ matrix.image == 'merod' && needs.prepare.outputs.docker_merod_tags || needs.prepare.outputs.docker_meroctl_tags }}
          labels: ${{ matrix.image == 'merod' && needs.prepare.outputs.docker_merod_labels || needs.prepare.outputs.docker_meroctl_labels }}
          provenance: mode=max
          sbom: true
          # Use load instead of push for test mode
          outputs: ${{ github.event.inputs.test_mode == 'true' && 'type=docker' || '' }}

      # Add a step to verify the image in test mode
      - name: Verify built Docker image
        if: github.event.inputs.test_mode == 'true'
        run: |
          echo "Verifying Docker image for ${{ matrix.image }}"
          docker image ls | grep "${{ matrix.image }}"
          # Test run the image
          docker run --rm ${{ matrix.image == 'merod' && needs.prepare.outputs.docker_merod_tags || needs.prepare.outputs.docker_meroctl_tags }} --version

  release:
    name: Create Release
    if: needs.prepare.outputs.release_required == 'true'
    runs-on: ubuntu-latest
    needs: [prepare, build-binaries-linux, build-binaries-macos, build-docker]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
          merge-multiple: true

      - name: Upload binaries to release
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: artifacts/*
          file_glob: true
          tag: ${{ needs.prepare.outputs.version }}
          release_name: ${{ needs.prepare.outputs.version }}
          prerelease: ${{ needs.prepare.outputs.prerelease }}
          overwrite: ${{ needs.prepare.outputs.overwrite_release }}
          target_commit: ${{ needs.prepare.outputs.target_commit }}

  brew-update:
    name: Bump Brew
    if: |
      needs.prepare.outputs.release_required == 'true' &&
      github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest
    needs: [prepare, build-binaries-linux, build-binaries-macos, release]
    steps:
      - name: Create GitHub App Token
        uses: actions/create-github-app-token@v1
        id: app-token
        with:
          app-id: ${{ vars.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: |
            homebrew-tap

      - name: Checkout homebrew-tap
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/homebrew-tap
          token: ${{ steps.app-token.outputs.token }}
          persist-credentials: false

      - name: Get GitHub App User ID
        id: get-user-id
        run: echo "user-id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Configure Git
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          gh auth setup-git
          git config --global user.name '${{ steps.app-token.outputs.app-slug }}[bot]'
          git config --global user.email '${{ steps.get-user-id.outputs.user-id }}+${{ steps.app-token.outputs.app-slug }}[bot]@users.noreply.github.com'

      - name: Update Formula
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          target_branch="chore/bump-formulas-version"
          git fetch origin "${target_branch}" || true
          git checkout "${target_branch}" || git checkout -b "${target_branch}"

          for binary in $(echo '${{ needs.prepare.outputs.binary_matrix }}' | jq -r '.[]'); do
            echo "Updating formula for ${binary}, version: ${version}"
            ./generate-formula.sh "${binary}" "${{ needs.prepare.outputs.version }}"
          done

          git status

          if git diff-index --quiet HEAD --; then
            echo "There are no changes to commit"
            exit 1
          fi

          git add Formula/
          git commit -m "chore: bump formulas version"
          git push origin "${target_branch}"

          gh pr create -f || true 