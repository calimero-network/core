name: Combined Release & Docker Build

on:
  workflow_dispatch:
    inputs:
      test_mode:
        description: 'Run in test mode (builds everything without releasing)'
        type: boolean
        default: true  # Default to test mode
  push:
    branches:
      - master
    paths:
      - Cargo.toml
      - Cargo.lock
      - 'crates/**'
      - 'core/Dockerfile'
      - '.github/workflows/combined-release.yml'
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - master
    paths:
      - Cargo.toml
      - Cargo.lock
      - 'crates/**'
      - 'core/Dockerfile'
      - '.github/workflows/combined-release.yml'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Testing mode: prepare job always sets build_required and docker_build_required to true
  prepare:
    name: Prepare
    runs-on: ubuntu-latest
    outputs:
      binary_matrix: ${{ steps.setup_matrix.outputs.binary_matrix }}
      version: ${{ steps.version_info.outputs.version }}
      release_required: false # Always false in test mode
      build_required: true # Always true in test mode
      target_commit: ${{ steps.version_info.outputs.target_commit }}
      prerelease: ${{ steps.version_info.outputs.prerelease }}
      overwrite_release: ${{ steps.version_info.outputs.overwrite_release }}
      docker_build_required: true # Always true in test mode
      docker_merod_tags: ${{ steps.docker_metadata.outputs.merod_tags }}
      docker_meroctl_tags: ${{ steps.docker_metadata.outputs.meroctl_tags }}
      docker_merod_labels: ${{ steps.docker_metadata.outputs.merod_labels }}
      docker_meroctl_labels: ${{ steps.docker_metadata.outputs.meroctl_labels }}
      shared_cargo_registry_key: ${{ steps.cache_keys.outputs.shared_cargo_registry_key }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup matrix
        id: setup_matrix
        run: |
          echo 'binary_matrix=["merod", "meroctl"]' >> "$GITHUB_OUTPUT"

      - name: Get version info
        id: version_info
        shell: bash
        run: |
          echo "Testing mode - using test version"
          echo "target_commit=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "version=test-$(date +%Y%m%d%H%M%S)" >> $GITHUB_OUTPUT
          echo "prerelease=true" >> $GITHUB_OUTPUT
          echo "overwrite_release=false" >> $GITHUB_OUTPUT

      - name: Docker image metadata preparation
        id: docker_metadata
        run: |
          VERSION="${{ steps.version_info.outputs.version }}"
          
          # Define tags for test images (not pushed to registry)
          MEROD_TAGS="merod:$VERSION"
          MEROCTL_TAGS="meroctl:$VERSION"
          
          # Define labels for both images
          COMMON_LABELS="{\"org.opencontainers.image.source\":\"https://github.com/${{ github.repository }}\",\"org.opencontainers.image.licenses\":\"MIT\"}"
          MEROD_LABELS="$COMMON_LABELS,{\"org.opencontainers.image.description\":\"Merod container image\"}"
          MEROCTL_LABELS="$COMMON_LABELS,{\"org.opencontainers.image.description\":\"Meroctl container image\"}"
          
          echo "merod_tags=$MEROD_TAGS" >> $GITHUB_OUTPUT
          echo "meroctl_tags=$MEROCTL_TAGS" >> $GITHUB_OUTPUT
          echo "merod_labels=$MEROD_LABELS" >> $GITHUB_OUTPUT
          echo "meroctl_labels=$MEROCTL_LABELS" >> $GITHUB_OUTPUT

      - name: Generate cache keys
        id: cache_keys
        run: |
          # Generate a hash of Cargo.lock for consistent caching
          CARGO_LOCK_HASH=$(sha256sum Cargo.lock | cut -d ' ' -f 1)
          echo "shared_cargo_registry_key=cargo-registry-$CARGO_LOCK_HASH" >> $GITHUB_OUTPUT

  build-binaries-linux:
    name: Build Linux Binaries
    # Always run for testing
    if: true
    runs-on: ubuntu-latest
    needs: prepare
    outputs:
      x86_64_linux_build_complete: true
      aarch64_linux_build_complete: true
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true

      - name: Add targets
        run: |
          # Only build x86_64 for testing
          rustup target add x86_64-unknown-linux-gnu

      - name: Cargo registry cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ needs.prepare.outputs.shared_cargo_registry_key }}
          restore-keys: |
            cargo-registry-

      - name: Cargo build cache x86_64
        uses: actions/cache@v4
        with:
          path: target/x86_64-unknown-linux-gnu
          key: cargo-build-x86_64-linux-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            cargo-build-x86_64-linux-

      # For testing - skip the complex cross-compilation setup
      # - name: Install dependencies for cross-compilation
      # - name: Download and set up OpenSSL for cross-compilation

      - name: Install musl-tools for static linking
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools

      - name: Add rust target for musl (static linking)
        run: rustup target add x86_64-unknown-linux-musl

      - name: Build x86_64 binaries with musl (static linking)
        run: |
          echo "Building x86_64-unknown-linux-musl binaries (statically linked)"
          binaries=$(echo '${{ needs.prepare.outputs.binary_matrix }}' | jq -r 'join(" ") | split(" ") | map("-p " + .) | join(" ")')
          # Build with musl for static linking
          RUSTFLAGS='-C target-feature=+crt-static' cargo build $binaries --release --target x86_64-unknown-linux-musl

      # Skip aarch64 builds for testing

      - name: Compress artifacts using gzip
        run: |
          mkdir -p artifacts
          echo '${{ needs.prepare.outputs.binary_matrix }}' | jq -r '.[]' | while read binary; do
            tar -czf artifacts/"$binary"_x86_64-unknown-linux-musl.tar.gz -C target/x86_64-unknown-linux-musl/release "$binary"
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-linux
          path: artifacts/*
          retention-days: 2

  # Comment out macOS builds for testing
  # build-binaries-macos:
  #   name: Build macOS Binaries
  #   ....

  build-docker:
    name: Build Docker Images
    needs: [prepare, build-binaries-linux]
    # Always run for testing
    if: true
    runs-on: ubuntu-latest
    timeout-minutes: 120
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        image: [merod, meroctl]
      fail-fast: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
      
      - name: Add targets
        run: |
          # Only x86_64 for testing
          rustup target add x86_64-unknown-linux-musl

      - name: Restore cargo registry cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ needs.prepare.outputs.shared_cargo_registry_key }}

      - name: Restore cargo build cache for musl
        uses: actions/cache@v4
        with:
          path: target/x86_64-unknown-linux-musl
          key: cargo-build-x86_64-linux-musl-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            cargo-build-x86_64-linux-musl-

      # Skip QEMU for testing (only building amd64)
      # - name: Set up QEMU
      #   uses: docker/setup-qemu-action@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      # Skip registry login for testing
      # - name: Log in to GitHub Container Registry
      #   uses: docker/login-action@v3
      #   with:
      #     registry: ghcr.io
      #     username: ${{ github.actor }}
      #     password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Prepare Docker context with pre-built binaries
        run: |
          mkdir -p .docker-context-${{ matrix.image }}
          # Copy only necessary files instead of recursively copying everything
          cp Dockerfile .docker-context-${{ matrix.image }}/
          cp Cargo.toml .docker-context-${{ matrix.image }}/
          cp Cargo.lock .docker-context-${{ matrix.image }}/
          mkdir -p .docker-context-${{ matrix.image }}/prebuild/linux/amd64
          # Use statically linked binaries
          cp target/x86_64-unknown-linux-musl/release/${{ matrix.image }} .docker-context-${{ matrix.image }}/prebuild/linux/amd64/
          
          # Check if binary is statically linked
          file target/x86_64-unknown-linux-musl/release/${{ matrix.image }}
          
          # Create a custom Dockerfile that uses pre-built binaries
          # Use a minimal Alpine container for statically linked binaries
          cat << EOF > .docker-context-${{ matrix.image }}/Dockerfile.prebuild
          # syntax=docker/dockerfile:1
          FROM alpine:latest AS ${{ matrix.image }}
          
          # Add labels for container metadata
          LABEL org.opencontainers.image.description="${{ matrix.image == 'merod' && 'Merod daemon' || 'Meroctl - Control tool for Merod daemon' }}"
          LABEL org.opencontainers.image.licenses="MIT"
          
          # Install only the essential runtime dependencies
          RUN apk --no-cache add ca-certificates
          
          # Create a non-privileged user for running the app
          RUN adduser -D -H -h /nonexistent -s /sbin/nologin -u 10001 appuser
          
          # Set the working directory
          WORKDIR /${{ matrix.image == 'merod' && 'data' || 'app' }}
          RUN chown appuser:appuser /${{ matrix.image == 'merod' && 'data' || 'app' }}
          
          # Copy the pre-built binary for the appropriate architecture
          COPY prebuild/linux/amd64/${{ matrix.image }} /usr/local/bin/${{ matrix.image }}
          RUN chmod +x /usr/local/bin/${{ matrix.image }}
          
          # Change to non-root user
          USER appuser
          
          # Set the entrypoint
          ENTRYPOINT ["${{ matrix.image }}"]
          CMD ["--help"]
          EOF

      - name: Build ${{ matrix.image }} image with pre-built binaries
        uses: docker/build-push-action@v5
        with:
          context: .docker-context-${{ matrix.image }}
          file: .docker-context-${{ matrix.image }}/Dockerfile.prebuild
          # Test mode - load locally, don't push
          push: false
          load: true
          # Only x86_64 for testing
          platforms: linux/amd64
          tags: ${{ matrix.image == 'merod' && needs.prepare.outputs.docker_merod_tags || needs.prepare.outputs.docker_meroctl_tags }}
          labels: ${{ matrix.image == 'merod' && needs.prepare.outputs.docker_merod_labels || needs.prepare.outputs.docker_meroctl_labels }}

      - name: Verify built Docker image
        run: |
          echo "Verifying Docker image for ${{ matrix.image }}"
          docker image ls | grep "${{ matrix.image }}"
          # Test run the image
          docker run --rm ${{ matrix.image == 'merod' && needs.prepare.outputs.docker_merod_tags || needs.prepare.outputs.docker_meroctl_tags }} --version

  # Comment out the release job for testing
  # release:
  #   name: Create Release
  #   if: needs.prepare.outputs.release_required == 'true'
  #   runs-on: ubuntu-latest
  #   needs: [prepare, build-binaries-linux, build-binaries-macos, build-docker]
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  # 
  #     - name: Download Artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         path: artifacts/
  #         merge-multiple: true
  # 
  #     - name: Upload binaries to release
  #       uses: svenstaro/upload-release-action@v2
  #       with:
  #         repo_token: ${{ secrets.GITHUB_TOKEN }}
  #         file: artifacts/*
  #         file_glob: true
  #         tag: ${{ needs.prepare.outputs.version }}
  #         release_name: ${{ needs.prepare.outputs.version }}
  #         prerelease: ${{ needs.prepare.outputs.prerelease }}
  #         overwrite: ${{ needs.prepare.outputs.overwrite_release }}
  #         target_commit: ${{ needs.prepare.outputs.target_commit }}
  
  # Comment out the brew-update job for testing
  # brew-update:
  #   name: Bump Brew
  #   if: |
  #     needs.prepare.outputs.release_required == 'true' &&
  #     github.ref == 'refs/heads/master'
  #   runs-on: ubuntu-latest
  #   needs: [prepare, build-binaries-linux, build-binaries-macos, release]
  #   steps:
  #     - name: Create GitHub App Token
  #       uses: actions/create-github-app-token@v1
  #       id: app-token
  #       with:
  #         app-id: ${{ vars.GH_APP_ID }}
  #         private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
  #         owner: ${{ github.repository_owner }}
  #         repositories: |
  #           homebrew-tap
  # 
  #     - name: Checkout homebrew-tap
  #       uses: actions/checkout@v4
  #       with:
  #         repository: ${{ github.repository_owner }}/homebrew-tap
  #         token: ${{ steps.app-token.outputs.token }}
  #         persist-credentials: false
  # 
  #     - name: Get GitHub App User ID
  #       id: get-user-id
  #       run: echo "user-id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)" >> "$GITHUB_OUTPUT"
  #       env:
  #         GH_TOKEN: ${{ steps.app-token.outputs.token }}
  # 
  #     - name: Configure Git
  #       env:
  #         GH_TOKEN: ${{ steps.app-token.outputs.token }}
  #       run: |
  #         gh auth setup-git
  #         git config --global user.name '${{ steps.app-token.outputs.app-slug }}[bot]'
  #         git config --global user.email '${{ steps.get-user-id.outputs.user-id }}+${{ steps.app-token.outputs.app-slug }}[bot]@users.noreply.github.com'
  # 
  #     - name: Update Formula
  #       env:
  #         GH_TOKEN: ${{ steps.app-token.outputs.token }}
  #       run: |
  #         target_branch="chore/bump-formulas-version"
  #         git fetch origin "${target_branch}" || true
  #         git checkout "${target_branch}" || git checkout -b "${target_branch}"
  # 
  #         for binary in $(echo '${{ needs.prepare.outputs.binary_matrix }}' | jq -r '.[]'); do
  #           echo "Updating formula for ${binary}, version: ${version}"
  #           ./generate-formula.sh "${binary}" "${{ needs.prepare.outputs.version }}"
  #         done
  # 
  #         git status
  # 
  #         if git diff-index --quiet HEAD --; then
  #           echo "There are no changes to commit"
  #           exit 1
  #         fi
  # 
  #         git add Formula/
  #         git commit -m "chore: bump formulas version"
  #         git push origin "${target_branch}"
  # 
  #         gh pr create -f || true 