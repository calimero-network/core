{
  "bounties": [
    {
      "title": "Race condition in JWT token rotation during refresh",
      "description": "In `refresh_token_pair()`, when rotating client tokens, a new key is stored before token generation. If token generation fails, cleanup attempts to delete the new key but the original key was already removed. This can leave users locked out with no valid key. The key operations need to be atomic or use a proper rollback strategy.",
      "pathHint": "crates/auth/src/auth/token/jwt.rs",
      "estimatedMinutes": 60,
      "category": "concurrency",
      "severity": "high"
    },
    {
      "title": "DeltaStore async methods hold RwLock across await points causing potential deadlock",
      "description": "Multiple methods like `add_delta_internal()` acquire write locks on `self.dag` and `self.head_root_hashes` separately across await points. When cascaded deltas trigger further operations, this can lead to deadlock or lock ordering violations. Refactor to minimize lock scope or use a single lock for related state.",
      "pathHint": "crates/node/src/delta_store.rs",
      "estimatedMinutes": 75,
      "category": "concurrency",
      "severity": "high"
    },
    {
      "title": "Context cache may serve stale dag_heads after network sync updates",
      "description": "The `get_or_fetch_context()` method refreshes dag_heads from database when cache is stale, but the check `cached.meta.dag_heads != meta.dag_heads` doesn't account for concurrent modifications between the check and update. This race can cause deltas to use wrong parents, breaking DAG consistency.",
      "pathHint": "crates/context/src/lib.rs",
      "estimatedMinutes": 60,
      "category": "concurrency",
      "severity": "high"
    },
    {
      "title": "Missing validation of parent IDs in CausalDelta allows malformed DAG",
      "description": "The `add_delta()` method in DagStore doesn't validate that parent IDs are valid 32-byte hashes or that they form a valid DAG structure. A malicious peer could send deltas with circular references or self-referential parents, potentially causing infinite loops in `apply_pending()` or corrupting DAG topology.",
      "pathHint": "crates/dag/src/lib.rs",
      "estimatedMinutes": 45,
      "category": "security",
      "severity": "high"
    },
    {
      "title": "Unsafe memory access in runtime logic without bounds checking",
      "description": "The `read_guest_memory_slice()` and `read_guest_memory_typed()` functions use `data_unchecked()` and `data_unchecked_mut()` without validating that the pointer/length are within bounds. A malicious WASM module could provide out-of-bounds pointers, causing undefined behavior.",
      "pathHint": "crates/runtime/src/logic.rs",
      "estimatedMinutes": 60,
      "category": "security",
      "severity": "critical"
    },
    {
      "title": "CSP configuration defaults allow unsafe-inline and unsafe-eval",
      "description": "The default Content Security Policy in `default_csp_script_src()` includes `'unsafe-inline'` and `'unsafe-eval'`, which defeats much of CSP's XSS protection. Additionally, `connect_src` allows `http:` which enables mixed content attacks. These should use nonces/hashes instead and restrict to HTTPS.",
      "pathHint": "crates/auth/src/config.rs",
      "estimatedMinutes": 45,
      "category": "security",
      "severity": "high"
    },
    {
      "title": "Node host validation can be bypassed with auth: prefix",
      "description": "In `validate_node_host()`, requests with host starting with `auth:` skip validation entirely. An attacker could set a forged X-Forwarded-Host header to `auth:malicious.com` to bypass token-to-host binding. The internal service check should use a more robust mechanism.",
      "pathHint": "crates/auth/src/auth/token/jwt.rs",
      "estimatedMinutes": 45,
      "category": "security",
      "severity": "high"
    },
    {
      "title": "Event handlers execute sequentially but may be documented as parallel-safe",
      "description": "The `execute_event_handlers_parsed()` function processes events sequentially with detailed comments about parallelization safety. However, the sequential execution combined with `.await` on each handler means slow handlers block subsequent events. If handlers are truly commutative as documented, parallelize with `join_all()`.",
      "pathHint": "crates/node/src/handlers/state_delta.rs",
      "estimatedMinutes": 60,
      "category": "design-flaw",
      "severity": "medium"
    },
    {
      "title": "Delta persistence not atomic - crash between put operations corrupts state",
      "description": "In `add_delta_internal()`, the delta is persisted with multiple separate `handle.put()` calls for the delta and context metadata. A crash between these operations leaves the database in an inconsistent state. Use a transaction or batch write to ensure atomicity.",
      "pathHint": "crates/node/src/delta_store.rs",
      "estimatedMinutes": 60,
      "category": "design-flaw",
      "severity": "high"
    },
    {
      "title": "Sync timeout divided by 3 or 6 can truncate to zero for short timeouts",
      "description": "Multiple places divide `sync_timeout` by small integers (e.g., `timeout / 3`, `timeout / 6`) for sub-operations. If configured timeout is small (e.g., 2 seconds), division can result in sub-second or near-zero timeouts causing spurious failures. Add minimum bounds or use saturating arithmetic.",
      "pathHint": "crates/node/src/sync/manager.rs",
      "estimatedMinutes": 30,
      "category": "bug",
      "severity": "medium"
    },
    {
      "title": "Missing error propagation in apply_pending causes silent delta loss",
      "description": "In `DagStore::apply_pending()`, errors from `apply_delta()` are propagated immediately, but if a delta in the middle of the ready list fails, previously successful deltas are committed while later ones remain pending. The function should either be atomic (all-or-nothing) or handle partial failures explicitly.",
      "pathHint": "crates/dag/src/lib.rs",
      "estimatedMinutes": 45,
      "category": "design-flaw",
      "severity": "high"
    },
    {
      "title": "Replace unsafe ptr::from_mut with safe RefCell borrowing pattern",
      "description": "The `children_cache()` method uses unsafe `ptr::from_mut` to extend the lifetime of a mutable reference from RefCell. This violates Rust's aliasing rules if the RefCell is borrowed elsewhere. Refactor to return a guard type or use safer interior mutability patterns.",
      "pathHint": "crates/storage/src/collections.rs",
      "estimatedMinutes": 60,
      "category": "bug",
      "severity": "high"
    },
    {
      "title": "Snapshot sync doesn't verify received state matches expected root hash",
      "description": "During snapshot sync, records are applied without verifying the resulting state matches the peer's claimed `boundary_root_hash`. A malicious peer could send corrupted or partial state. Add verification step that computes and compares root hash after applying all records.",
      "pathHint": "crates/node/src/sync/snapshot.rs",
      "estimatedMinutes": 60,
      "category": "security",
      "severity": "high"
    },
    {
      "title": "Introduce proper error type for DeltaStore and propagate throughout",
      "description": "DeltaStore methods return `eyre::Result` with string-formatted errors, making programmatic error handling difficult. Create a dedicated `DeltaStoreError` enum with variants for each failure mode (persistence, application, missing parents) and propagate through all call sites.",
      "pathHint": "crates/node/src/delta_store.rs",
      "estimatedMinutes": 75,
      "category": "design-flaw",
      "severity": "medium"
    },
    {
      "title": "SyncManager clone loses ctx_sync_rx causing silent sync failures",
      "description": "The `Clone` impl for `SyncManager` sets `ctx_sync_rx: None` because receivers can't be cloned. If a cloned instance is used, it will miss all sync requests sent via the channel. Either prevent cloning or document this behavior prominently with runtime detection.",
      "pathHint": "crates/node/src/sync/manager.rs",
      "estimatedMinutes": 45,
      "category": "design-flaw",
      "severity": "medium"
    },
    {
      "title": "NetworkClient methods panic on mailbox drop instead of returning errors",
      "description": "All methods in NetworkClient use `.expect(\"Mailbox not to be dropped\")` on both send and receive operations. If the NetworkManager actor is shut down, this causes panics throughout the codebase. Replace with proper error handling returning `Result` types.",
      "pathHint": "crates/network/primitives/src/client.rs",
      "estimatedMinutes": 60,
      "category": "design-flaw",
      "severity": "high"
    },
    {
      "title": "InMemoryDB unsafe Send/Sync implementations may cause data races",
      "description": "The `InMemoryDB` struct has manual `unsafe impl Send` and `unsafe impl Sync` with TODO comments indicating this is temporary. The inner `Slice` type may not be thread-safe, potentially causing data races in multi-threaded test scenarios.",
      "pathHint": "crates/store/src/db/memory.rs",
      "estimatedMinutes": 60,
      "category": "concurrency",
      "severity": "high"
    },
    {
      "title": "Unsafe transmute in create_context extends VacantEntry lifetime incorrectly",
      "description": "In `Prepared::new()`, there's an unsafe transmute to convert a VacantEntry to a 'static lifetime with a comment claiming it's safe. However, if the BTreeMap is modified before the entry is used, this can cause use-after-free. Refactor to avoid the transmute.",
      "pathHint": "crates/context/src/handlers/create_context.rs",
      "estimatedMinutes": 60,
      "category": "bug",
      "severity": "critical"
    },
    {
      "title": "WebSocket connection ID collision possible with random generation",
      "description": "In `handle_socket()`, connection IDs are generated using `random()` in a loop until unique. With high connection churn, this could theoretically loop indefinitely or cause ID reuse after connection cleanup. Use a monotonic counter or UUIDs instead.",
      "pathHint": "crates/server/src/ws.rs",
      "estimatedMinutes": 30,
      "category": "design-flaw",
      "severity": "low"
    },
    {
      "title": "Session expiry check uses Relaxed ordering causing stale reads",
      "description": "The `is_expired()` method loads `last_activity` with `Ordering::Relaxed`, which may see stale values on multi-core systems. The `touch()` method uses `SeqCst` but the reader uses `Relaxed`, creating inconsistency. Use matching orderings for both read and write.",
      "pathHint": "crates/server/src/sse/session.rs",
      "estimatedMinutes": 30,
      "category": "concurrency",
      "severity": "medium"
    },
    {
      "title": "SharedKey ECDH uses ed25519 directly instead of X25519 conversion",
      "description": "The `SharedKey::new()` performs ECDH by directly multiplying ed25519 signing key scalar with public key point. While this works, it's non-standard and may have subtle security implications. The proper approach is to convert to X25519 keys first using established transformations.",
      "pathHint": "crates/crypto/src/lib.rs",
      "estimatedMinutes": 75,
      "category": "security",
      "severity": "medium"
    },
    {
      "title": "Gossipsub uses default config without message validation or flood limits",
      "description": "The gossipsub Behaviour is initialized with `gossipsub::Config::default()` without configuring message validation, flood publishing limits, or score parameters. This allows peers to flood the mesh with invalid or duplicate messages causing DoS.",
      "pathHint": "crates/network/src/behaviour.rs",
      "estimatedMinutes": 60,
      "category": "security",
      "severity": "high"
    },
    {
      "title": "decode_snapshot_records advances offset incorrectly causing infinite loop",
      "description": "In `decode_snapshot_records()`, the offset is advanced by re-serializing the decoded record (`borsh::to_vec(&record)?.len()`), which may differ from the original serialized size. This can cause infinite loops or skip records. Track the actual bytes consumed during deserialization.",
      "pathHint": "crates/node/src/sync/snapshot.rs",
      "estimatedMinutes": 45,
      "category": "bug",
      "severity": "high"
    },
    {
      "title": "JSON-RPC handler logs request args potentially exposing sensitive data",
      "description": "The `handle_request()` function logs `args=%exec_request.args_json` at INFO level. If arguments contain sensitive data (private keys, secrets, PII), they will appear in logs. Sanitize or redact sensitive fields before logging.",
      "pathHint": "crates/server/src/jsonrpc.rs",
      "estimatedMinutes": 45,
      "category": "security",
      "severity": "medium"
    },
    {
      "title": "SystemTime::now() can panic or return incorrect values during NTP adjustments",
      "description": "Multiple files use `SystemTime::now().duration_since(UNIX_EPOCH).expect()` which can panic if system time is before UNIX epoch (during misconfiguration or NTP adjustments). Use a fallback value or handle the error gracefully.",
      "pathHint": "crates/server/src/ws.rs",
      "estimatedMinutes": 30,
      "category": "bug",
      "severity": "low"
    },
    {
      "title": "cleanup_stale_keys during snapshot sync doesn't handle concurrent writes",
      "description": "The `request_and_apply_snapshot_pages` method collects existing keys, applies new keys, then deletes stale keys. If concurrent writes occur (despite the documented assumption), new keys written during sync would be deleted. Add explicit locking or use a database transaction.",
      "pathHint": "crates/node/src/sync/snapshot.rs",
      "estimatedMinutes": 60,
      "category": "concurrency",
      "severity": "medium"
    },
    {
      "title": "Hash bs58 encoding can panic if MAX_STR_LEN constant is incorrect",
      "description": "The `From<[u8; BYTES_LEN]> for Hash` implementation uses `.expect()` on bs58 encoding, which panics if MAX_STR_LEN is wrong. While unlikely, this should return a Result or use a compile-time assertion to guarantee correctness.",
      "pathHint": "crates/primitives/src/hash.rs",
      "estimatedMinutes": 30,
      "category": "bug",
      "severity": "low"
    },
    {
      "title": "from_utf8_unchecked in Hash::as_str assumes bs58 cache is valid UTF-8",
      "description": "The `as_str()` method uses `from_utf8_unchecked` with a safety comment. However, if the bs58_cache is corrupted (memory safety issue elsewhere), this becomes UB. Replace with `from_utf8().expect()` for defense in depth without meaningful performance impact.",
      "pathHint": "crates/primitives/src/hash.rs",
      "estimatedMinutes": 20,
      "category": "bug",
      "severity": "low"
    },
    {
      "title": "idle_connection_timeout of 30s may close connections during slow sync",
      "description": "The swarm config sets `idle_connection_timeout(Duration::from_secs(30))`. During large snapshot syncs or slow networks, connections can timeout mid-transfer, requiring restart. Make this configurable or increase default for sync operations.",
      "pathHint": "crates/network/src/behaviour.rs",
      "estimatedMinutes": 30,
      "category": "design-flaw",
      "severity": "medium"
    },
    {
      "title": "Context creation retries only 5 times with fixed seed causing guaranteed failure",
      "description": "In `Prepared::new()`, if a seed is provided and the context already exists, the function bails after one try. But if seed is None, it retries 5 times with random IDs. With a fixed seed, collision is deterministic and retrying is pointless. Improve error messaging and handling.",
      "pathHint": "crates/context/src/handlers/create_context.rs",
      "estimatedMinutes": 30,
      "category": "bug",
      "severity": "low"
    }
  ]
}
