use rand::RngCore;

use crate::logic::{sys, VMHostFunctions, VMLogicResult};
use calimero_primitives::common::DIGEST_SIZE;

impl VMHostFunctions<'_> {
    /// Creates a new governance proposal.
    ///
    /// Call the contract's `send_proposal()` function through the bridge.
    ///
    /// The proposal actions are obtained as raw data and pushed onto a list of
    /// proposals to be sent to the host.
    ///
    /// Note that multiple actions are received, and the entire batch is pushed
    /// onto the proposal list to represent one proposal.
    ///
    /// A unique ID for the proposal is generated by the host and written back into
    /// guest memory. The proposal itself is stored in the `VMLogic` to be included
    /// in the `Outcome`.
    ///
    /// # Arguments
    ///
    /// * `src_actions_ptr` - pointer to a source-buffer `sys::Buffer` in guest memory,
    /// containing the proposal's actions.
    /// * `dest_id_ptr` - A pointer to a 32-byte destination buffer `sys::BufferMut`
    /// in guest memory where the generated proposal ID will be written.
    ///
    /// # Errors
    ///
    /// * `HostError::InvalidMemoryAccess` if memory access fails for descriptor buffers.
    pub fn send_proposal(&mut self, src_actions_ptr: u64, dest_id_ptr: u64) -> VMLogicResult<()> {
        let actions = unsafe { self.read_guest_memory_typed::<sys::Buffer<'_>>(src_actions_ptr)? };
        let dest_id = unsafe { self.read_guest_memory_typed::<sys::BufferMut<'_>>(dest_id_ptr)? };

        // Validate both buffers BEFORE generating the proposal_id to ensure
        // we don't write an orphaned ID to guest memory if validation fails.
        let actions = self.read_guest_memory_slice(&actions)?.to_vec();
        // Validate dest_id bounds before generating proposal_id
        {
            let _bounds_check = self.read_guest_memory_slice_mut(&dest_id)?;
        }

        let mut proposal_id = [0_u8; DIGEST_SIZE];
        rand::thread_rng().fill_bytes(&mut proposal_id);

        // Record newly created ID to guest memory
        let dest_id_buf: &mut [u8] = self.read_guest_memory_slice_mut(&dest_id)?;
        dest_id_buf.copy_from_slice(&proposal_id);

        let _ignored = self.with_logic_mut(|logic| logic.proposals.insert(proposal_id, actions));
        Ok(())
    }

    /// Approves a governance proposal.
    ///
    /// Adds the given proposal ID to the list of approvals in the `VMLogic`.
    ///
    /// # Arguments
    ///
    /// * `src_approval_ptr` - Pointer to a 32-byte source-buffer `sys::Buffer`
    /// in guest memory containing the ID of the proposal to approve.
    ///
    /// # Errors
    ///
    /// * `HostError::InvalidMemoryAccess` if memory access fails for descriptor buffers.
    pub fn approve_proposal(&mut self, src_approval_ptr: u64) -> VMLogicResult<()> {
        let approval =
            unsafe { self.read_guest_memory_typed::<sys::Buffer<'_>>(src_approval_ptr)? };
        let approval = *self.read_guest_memory_sized::<DIGEST_SIZE>(&approval)?;

        self.with_logic_mut(|logic| logic.approvals.push(approval));
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use crate::logic::{
        tests::{prepare_guest_buf_descriptor, setup_vm, SimpleMockStorage},
        Cow, VMContext, VMLimits, VMLogic,
    };
    use calimero_primitives::common::DIGEST_SIZE;
    use wasmer::{AsStoreMut, Store};

    /// Tests the `send_proposal()` and `approve_proposal()` host functions.
    #[test]
    fn test_proposals_send_approve() {
        let mut storage = SimpleMockStorage::new();
        let limits = VMLimits::default();
        let (mut logic, mut store) = setup_vm!(&mut storage, &limits, vec![]);
        let mut host = logic.host_functions(store.as_store_mut());

        // Test sending a proposal.
        let actions = vec![1, 2, 3, 4, 5, 6];
        let actions_ptr = 100u64;
        // Write actions to guest memory.
        host.borrow_memory().write(actions_ptr, &actions).unwrap();
        let actions_buf_ptr = 16u64;
        // Guest: prepare the descriptor for the destination buffer so host can access it.
        prepare_guest_buf_descriptor(&host, actions_buf_ptr, actions_ptr, actions.len() as u64);

        let id_out_ptr = 300u64;
        let id_buf_ptr = 32u64;
        // Guest: prepare the descriptor for the destination buffer so host can write there.
        prepare_guest_buf_descriptor(&host, id_buf_ptr, id_out_ptr, DIGEST_SIZE as u64);
        // Guest: send proposal to host with actions `actions_buf_ptr` and get back the proposal ID
        // in `id_buf_ptr`.
        host.send_proposal(actions_buf_ptr, id_buf_ptr).unwrap();

        // Verify the proposal with the given actions were successfully added.
        assert_eq!(host.borrow_logic().proposals.len(), 1);
        assert_eq!(
            host.borrow_logic().proposals.values().next().unwrap(),
            &actions
        );
        // Verify there are no approvals yet.
        assert_eq!(host.borrow_logic().approvals.len(), 0);

        // Test approving a proposal.
        // Approval ID is the Answer to the Ultimate Question of Life, the Universe, and Everything.
        let approval_id = [42u8; DIGEST_SIZE];
        let approval_ptr = 500u64;
        // Write approval to guest memory.
        host.borrow_memory()
            .write(approval_ptr, &approval_id)
            .unwrap();

        let approval_buf_ptr = 48u64;
        // Guest: prepare the descriptor for the destination buffer so host can access it.
        prepare_guest_buf_descriptor(
            &host,
            approval_buf_ptr,
            approval_ptr,
            approval_id.len() as u64,
        );

        // Guest: send a proposal approval to host.
        host.approve_proposal(approval_buf_ptr).unwrap();

        // Verify the host successfully stored the approval and its ID matches the one we sent.
        assert_eq!(host.borrow_logic().approvals.len(), 1);
        assert_eq!(host.borrow_logic().approvals[0], approval_id);
    }

    /// Tests sending a proposal with empty actions.
    #[test]
    fn test_send_proposal_with_empty_actions() {
        let mut storage = SimpleMockStorage::new();
        let limits = VMLimits::default();
        let (mut logic, mut store) = setup_vm!(&mut storage, &limits, vec![]);
        let mut host = logic.host_functions(store.as_store_mut());

        // Test sending a proposal with empty actions.
        let actions: Vec<u8> = vec![];
        let actions_ptr = 100u64;
        let actions_buf_ptr = 16u64;
        // Guest: prepare the descriptor for an empty buffer.
        prepare_guest_buf_descriptor(&host, actions_buf_ptr, actions_ptr, 0);

        let id_out_ptr = 300u64;
        let id_buf_ptr = 32u64;
        // Guest: prepare the descriptor for the destination buffer.
        prepare_guest_buf_descriptor(&host, id_buf_ptr, id_out_ptr, DIGEST_SIZE as u64);

        // Guest: send proposal with empty actions.
        host.send_proposal(actions_buf_ptr, id_buf_ptr).unwrap();

        // Verify the proposal was successfully added with empty actions.
        assert_eq!(host.borrow_logic().proposals.len(), 1);
        assert_eq!(
            host.borrow_logic().proposals.values().next().unwrap(),
            &actions
        );
    }

    /// Tests sending multiple proposals generates unique IDs.
    #[test]
    fn test_send_multiple_proposals_generates_unique_ids() {
        let mut storage = SimpleMockStorage::new();
        let limits = VMLimits::default();
        let (mut logic, mut store) = setup_vm!(&mut storage, &limits, vec![]);
        let mut host = logic.host_functions(store.as_store_mut());

        // Send first proposal.
        let actions1 = vec![1, 2, 3];
        let actions1_ptr = 100u64;
        host.borrow_memory().write(actions1_ptr, &actions1).unwrap();
        let actions1_buf_ptr = 16u64;
        prepare_guest_buf_descriptor(&host, actions1_buf_ptr, actions1_ptr, actions1.len() as u64);

        let id1_out_ptr = 300u64;
        let id1_buf_ptr = 32u64;
        prepare_guest_buf_descriptor(&host, id1_buf_ptr, id1_out_ptr, DIGEST_SIZE as u64);

        host.send_proposal(actions1_buf_ptr, id1_buf_ptr).unwrap();

        // Read the first proposal ID from guest memory.
        let mut proposal_id_1 = [0u8; DIGEST_SIZE];
        host.borrow_memory()
            .read(id1_out_ptr, &mut proposal_id_1)
            .unwrap();

        // Send second proposal.
        let actions2 = vec![4, 5, 6];
        let actions2_ptr = 400u64;
        host.borrow_memory().write(actions2_ptr, &actions2).unwrap();
        let actions2_buf_ptr = 48u64;
        prepare_guest_buf_descriptor(&host, actions2_buf_ptr, actions2_ptr, actions2.len() as u64);

        let id2_out_ptr = 500u64;
        let id2_buf_ptr = 64u64;
        prepare_guest_buf_descriptor(&host, id2_buf_ptr, id2_out_ptr, DIGEST_SIZE as u64);

        host.send_proposal(actions2_buf_ptr, id2_buf_ptr).unwrap();

        // Read the second proposal ID from guest memory.
        let mut proposal_id_2 = [0u8; DIGEST_SIZE];
        host.borrow_memory()
            .read(id2_out_ptr, &mut proposal_id_2)
            .unwrap();

        // Verify both proposals were added.
        assert_eq!(host.borrow_logic().proposals.len(), 2);

        // Verify the proposal IDs are different (with very high probability since they're random).
        // Note: This test has a negligible probability of failing due to random collision.
        assert_ne!(proposal_id_1, proposal_id_2);
    }

    /// Tests approving multiple proposals.
    #[test]
    fn test_approve_multiple_proposals() {
        let mut storage = SimpleMockStorage::new();
        let limits = VMLimits::default();
        let (mut logic, mut store) = setup_vm!(&mut storage, &limits, vec![]);
        let mut host = logic.host_functions(store.as_store_mut());

        // First approval.
        let approval_id_1 = [1u8; DIGEST_SIZE];
        let approval_ptr_1 = 100u64;
        host.borrow_memory()
            .write(approval_ptr_1, &approval_id_1)
            .unwrap();
        let approval_buf_ptr_1 = 16u64;
        prepare_guest_buf_descriptor(
            &host,
            approval_buf_ptr_1,
            approval_ptr_1,
            DIGEST_SIZE as u64,
        );

        host.approve_proposal(approval_buf_ptr_1).unwrap();

        // Second approval.
        let approval_id_2 = [2u8; DIGEST_SIZE];
        let approval_ptr_2 = 200u64;
        host.borrow_memory()
            .write(approval_ptr_2, &approval_id_2)
            .unwrap();
        let approval_buf_ptr_2 = 32u64;
        prepare_guest_buf_descriptor(
            &host,
            approval_buf_ptr_2,
            approval_ptr_2,
            DIGEST_SIZE as u64,
        );

        host.approve_proposal(approval_buf_ptr_2).unwrap();

        // Third approval.
        let approval_id_3 = [3u8; DIGEST_SIZE];
        let approval_ptr_3 = 300u64;
        host.borrow_memory()
            .write(approval_ptr_3, &approval_id_3)
            .unwrap();
        let approval_buf_ptr_3 = 48u64;
        prepare_guest_buf_descriptor(
            &host,
            approval_buf_ptr_3,
            approval_ptr_3,
            DIGEST_SIZE as u64,
        );

        host.approve_proposal(approval_buf_ptr_3).unwrap();

        // Verify all approvals were stored in order.
        assert_eq!(host.borrow_logic().approvals.len(), 3);
        assert_eq!(host.borrow_logic().approvals[0], approval_id_1);
        assert_eq!(host.borrow_logic().approvals[1], approval_id_2);
        assert_eq!(host.borrow_logic().approvals[2], approval_id_3);
    }

    /// Tests approving the same proposal ID multiple times (allowed).
    #[test]
    fn test_approve_same_proposal_multiple_times() {
        let mut storage = SimpleMockStorage::new();
        let limits = VMLimits::default();
        let (mut logic, mut store) = setup_vm!(&mut storage, &limits, vec![]);
        let mut host = logic.host_functions(store.as_store_mut());

        let approval_id = [42u8; DIGEST_SIZE];
        let approval_ptr = 100u64;
        host.borrow_memory()
            .write(approval_ptr, &approval_id)
            .unwrap();
        let approval_buf_ptr = 16u64;
        prepare_guest_buf_descriptor(&host, approval_buf_ptr, approval_ptr, DIGEST_SIZE as u64);

        // Approve the same proposal three times.
        host.approve_proposal(approval_buf_ptr).unwrap();
        host.approve_proposal(approval_buf_ptr).unwrap();
        host.approve_proposal(approval_buf_ptr).unwrap();

        // All three approvals should be recorded (deduplication is handled elsewhere).
        assert_eq!(host.borrow_logic().approvals.len(), 3);
        assert!(host
            .borrow_logic()
            .approvals
            .iter()
            .all(|id| *id == approval_id));
    }

    /// Tests sending a proposal with large actions data.
    #[test]
    fn test_send_proposal_with_large_actions() {
        let mut storage = SimpleMockStorage::new();
        let limits = VMLimits::default();
        let (mut logic, mut store) = setup_vm!(&mut storage, &limits, vec![]);
        let mut host = logic.host_functions(store.as_store_mut());

        // Create a large actions payload.
        let actions: Vec<u8> = (0..1000).map(|i| (i % 256) as u8).collect();
        let actions_ptr = 100u64;
        host.borrow_memory().write(actions_ptr, &actions).unwrap();
        let actions_buf_ptr = 16u64;
        prepare_guest_buf_descriptor(&host, actions_buf_ptr, actions_ptr, actions.len() as u64);

        let id_out_ptr = 2000u64;
        let id_buf_ptr = 32u64;
        prepare_guest_buf_descriptor(&host, id_buf_ptr, id_out_ptr, DIGEST_SIZE as u64);

        host.send_proposal(actions_buf_ptr, id_buf_ptr).unwrap();

        // Verify the proposal was added with the correct large actions.
        assert_eq!(host.borrow_logic().proposals.len(), 1);
        assert_eq!(
            host.borrow_logic().proposals.values().next().unwrap(),
            &actions
        );
    }

    /// Tests that proposal IDs are written to guest memory correctly.
    #[test]
    fn test_proposal_id_written_to_guest_memory() {
        let mut storage = SimpleMockStorage::new();
        let limits = VMLimits::default();
        let (mut logic, mut store) = setup_vm!(&mut storage, &limits, vec![]);
        let mut host = logic.host_functions(store.as_store_mut());

        let actions = vec![1, 2, 3];
        let actions_ptr = 100u64;
        host.borrow_memory().write(actions_ptr, &actions).unwrap();
        let actions_buf_ptr = 16u64;
        prepare_guest_buf_descriptor(&host, actions_buf_ptr, actions_ptr, actions.len() as u64);

        let id_out_ptr = 300u64;
        let id_buf_ptr = 32u64;
        prepare_guest_buf_descriptor(&host, id_buf_ptr, id_out_ptr, DIGEST_SIZE as u64);

        host.send_proposal(actions_buf_ptr, id_buf_ptr).unwrap();

        // Read the proposal ID from guest memory.
        let mut written_id = [0u8; DIGEST_SIZE];
        host.borrow_memory()
            .read(id_out_ptr, &mut written_id)
            .unwrap();

        // Verify the written ID matches the key in proposals map.
        let stored_key = *host.borrow_logic().proposals.keys().next().unwrap();
        assert_eq!(written_id, stored_key);
    }
}
