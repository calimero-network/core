use rand::RngCore;

use crate::logic::{sys, VMHostFunctions, VMLogicResult, DIGEST_SIZE};

impl VMHostFunctions<'_> {
    /// Creates a new governance proposal.
    ///
    /// Call the contract's `send_proposal()` function through the bridge.
    ///
    /// The proposal actions are obtained as raw data and pushed onto a list of
    /// proposals to be sent to the host.
    ///
    /// Note that multiple actions are received, and the entire batch is pushed
    /// onto the proposal list to represent one proposal.
    ///
    /// A unique ID for the proposal is generated by the host and written back into
    /// guest memory. The proposal itself is stored in the `VMLogic` to be included
    /// in the `Outcome`.
    ///
    /// # Arguments
    ///
    /// * `src_actions_ptr` - pointer to a source-buffer `sys::Buffer` in guest memory,
    /// containing the proposal's actions.
    /// * `dest_id_ptr` - A pointer to a 32-byte destination buffer `sys::BufferMut`
    /// in guest memory where the generated proposal ID will be written.
    ///
    /// # Errors
    ///
    /// * `HostError::InvalidMemoryAccess` if memory access fails for descriptor buffers.
    pub fn send_proposal(&mut self, src_actions_ptr: u64, dest_id_ptr: u64) -> VMLogicResult<()> {
        let actions = unsafe { self.read_guest_memory_typed::<sys::Buffer<'_>>(src_actions_ptr)? };
        let dest_id = unsafe { self.read_guest_memory_typed::<sys::BufferMut<'_>>(dest_id_ptr)? };

        let mut proposal_id = [0u8; DIGEST_SIZE];
        rand::thread_rng().fill_bytes(&mut proposal_id);

        // Record newly created ID to guest memory
        let dest_id: &mut [u8] = self.read_guest_memory_slice_mut(&dest_id);
        dest_id.copy_from_slice(&proposal_id);

        let actions = self.read_guest_memory_slice(&actions).to_vec();

        let _ignored = self.with_logic_mut(|logic| logic.proposals.insert(proposal_id, actions));
        Ok(())
    }

    /// Approves a governance proposal.
    ///
    /// Adds the given proposal ID to the list of approvals in the `VMLogic`.
    ///
    /// # Arguments
    ///
    /// * `src_approval_ptr` - Pointer to a 32-byte source-buffer `sys::Buffer`
    /// in guest memory containing the ID of the proposal to approve.
    ///
    /// # Errors
    ///
    /// * `HostError::InvalidMemoryAccess` if memory access fails for descriptor buffers.
    pub fn approve_proposal(&mut self, src_approval_ptr: u64) -> VMLogicResult<()> {
        let approval =
            unsafe { self.read_guest_memory_typed::<sys::Buffer<'_>>(src_approval_ptr)? };
        let approval = *self.read_guest_memory_sized::<DIGEST_SIZE>(&approval)?;

        let _ignored = self.with_logic_mut(|logic| logic.approvals.push(approval));
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use crate::logic::{
        tests::{prepare_guest_buf_descriptor, setup_vm, SimpleMockStorage},
        Cow, VMContext, VMLimits, VMLogic, DIGEST_SIZE,
    };
    use wasmer::{AsStoreMut, Store};

    /// Tests the `send_proposal()` and `approve_proposal()` host functions.
    #[test]
    fn test_proposals_send_approve() {
        let mut storage = SimpleMockStorage::new();
        let limits = VMLimits::default();
        let (mut logic, mut store) = setup_vm!(&mut storage, &limits, vec![]);
        let mut host = logic.host_functions(store.as_store_mut());

        // Test sending a proposal.
        let actions = vec![1, 2, 3, 4, 5, 6];
        let actions_ptr = 100u64;
        // Write actions to guest memory.
        host.borrow_memory().write(actions_ptr, &actions).unwrap();
        let actions_buf_ptr = 16u64;
        // Guest: prepare the descriptor for the destination buffer so host can access it.
        prepare_guest_buf_descriptor(&host, actions_buf_ptr, actions_ptr, actions.len() as u64);

        let id_out_ptr = 300u64;
        let id_buf_ptr = 32u64;
        // Guest: prepare the descriptor for the destination buffer so host can write there.
        prepare_guest_buf_descriptor(&host, id_buf_ptr, id_out_ptr, DIGEST_SIZE as u64);
        // Guest: send proposal to host with actions `actions_buf_ptr` and get back the proposal ID
        // in `id_buf_ptr`.
        host.send_proposal(actions_buf_ptr, id_buf_ptr).unwrap();

        // Verify the proposal with the given actions were successfully added.
        assert_eq!(host.borrow_logic().proposals.len(), 1);
        assert_eq!(
            host.borrow_logic().proposals.values().next().unwrap(),
            &actions
        );
        // Verify there are no approvals yet.
        assert_eq!(host.borrow_logic().approvals.len(), 0);

        // Test approving a proposal.
        // Approval ID is the Answer to the Ultimate Question of Life, the Universe, and Everything.
        let approval_id = [42u8; DIGEST_SIZE];
        let approval_ptr = 500u64;
        // Write approval to guest memory.
        host.borrow_memory()
            .write(approval_ptr, &approval_id)
            .unwrap();

        let approval_buf_ptr = 48u64;
        // Guest: prepare the descriptor for the destination buffer so host can access it.
        prepare_guest_buf_descriptor(
            &host,
            approval_buf_ptr,
            approval_ptr,
            approval_id.len() as u64,
        );

        // Guest: send a proposal approval to host.
        host.approve_proposal(approval_buf_ptr).unwrap();

        // Verify the host successfully stored the approval and its ID matches the one we sent.
        assert_eq!(host.borrow_logic().approvals.len(), 1);
        assert_eq!(host.borrow_logic().approvals[0], approval_id);
    }
}
