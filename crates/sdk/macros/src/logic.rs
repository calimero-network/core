use proc_macro2::TokenStream;
use quote::{format_ident, quote, ToTokens};
use syn::{parse2, Data, DataEnum, Error as SynError, Fields, GenericParam, ImplItem, ItemImpl, Type, TypePath};

use crate::errors::{Errors, ParseError};
use crate::logic::method::{LogicMethod, LogicMethodImplInput, PublicLogicMethod};
use crate::logic::utils::typed_path;
use crate::macros::infallible;
use crate::reserved::{idents, lifetimes};
use crate::sanitizer::{Action, Case, Sanitizer};

mod arg;
mod method;
mod ty;
mod utils;

// Helper function to convert PascalCase to snake_case
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    let mut chars = s.chars().peekable();
    
    while let Some(c) = chars.next() {
        if c.is_uppercase() && !result.is_empty() {
            result.push('_');
        }
        result.push(c.to_lowercase().next().unwrap_or(c));
    }
    
    result
}

pub struct LogicImpl<'a> {
    methods: Vec<PublicLogicMethod<'a>>,
    orig: &'a ItemImpl,
}

impl ToTokens for LogicImpl<'_> {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let LogicImpl { orig, methods, .. } = self;
        
        // Extract the type name and generics from the impl block
        let type_name = &orig.self_ty;
        let (impl_generics, ty_generics, where_clause) = orig.generics.split_for_impl();

        // Always generate the process_events method for all apps
        let process_events_method = quote! {
            /// Process remote events for automatic callbacks
            ///
            /// Uses the `#[derive(CallbackHandlers)]` dispatcher generated from the `Event` enum
            /// to decode and call the appropriate per-variant handler implemented on `self`.
            /// This method is generated when `#[app::logic]` is used.
            pub fn process_events(&mut self, event_kind: ::std::string::String, event_data: ::std::vec::Vec<u8>) -> ::calimero_sdk::app::Result<()> {
                // Debug: This method was generated by #[app::logic] macro
                ::std::println!("DEBUG: process_events method called");
                // Use the event type from the AppState trait to dispatch events
                <#type_name as ::calimero_sdk::state::AppState>::Event::dispatch(self, &event_kind, &event_data)
            }
        };

        // Generate a default CallbackHandlers implementation
        let callback_handlers_impl = quote! {
            impl #impl_generics CallbackHandlers for #type_name #ty_generics #where_clause {
                // Default no-op implementation
                // Apps can override specific methods as needed
            }
        };

        // Parse the method as an ImplItem
        let method_item: ImplItem = parse2(process_events_method).unwrap();

        // Create a new impl block with the method added
        let mut new_impl = (*orig).clone();
        
        // Find and replace the placeholder process_events method
        let mut found_placeholder = false;
        for (i, item) in new_impl.items.iter_mut().enumerate() {
            if let syn::ImplItem::Fn(method) = item {
                if method.sig.ident == "process_events" {
                    // Replace the placeholder with the real implementation
                    *item = method_item.clone();
                    found_placeholder = true;
                    break;
                }
            }
        }
        
        // If no placeholder was found, add the method
        if !found_placeholder {
            new_impl.items.push(method_item);
        }

        quote! {
            #new_impl

            #callback_handlers_impl

            #(#methods)*
        }
        .to_tokens(tokens);
    }
}

pub struct LogicImplInput<'a> {
    pub item: &'a ItemImpl,
}

impl<'a> TryFrom<LogicImplInput<'a>> for LogicImpl<'a> {
    type Error = Errors<'a, ItemImpl>;

    // TODO: This unwrap() call needs to be corrected to return an error.
    #[expect(clippy::unwrap_in_result, reason = "TODO: This is temporary")]
    fn try_from(input: LogicImplInput<'a>) -> Result<Self, Self::Error> {
        let errors = Errors::new(input.item);

        for generic in &input.item.generics.params {
            if let GenericParam::Lifetime(params) = generic {
                if params.lifetime == *lifetimes::input() {
                    errors.subsume(SynError::new(
                        params.lifetime.span(),
                        ParseError::UseOfReservedLifetime,
                    ));
                }
                continue;
            }
            errors.subsume(SynError::new_spanned(
                generic,
                ParseError::NoGenericTypeSupport,
            ));
        }

        if input.item.trait_.is_some() {
            return Err(errors.finish(SynError::new_spanned(
                input.item,
                ParseError::NoTraitSupport,
            )));
        }

        let Some(type_) = typed_path(input.item.self_ty.as_ref(), false) else {
            return Err(errors.finish(SynError::new_spanned(
                &input.item.self_ty,
                ParseError::UnsupportedImplType,
            )));
        };

        let mut sanitizer = parse2::<Sanitizer<'_>>(type_.to_token_stream()).unwrap();

        let reserved_ident = idents::input();
        let reserved_lifetime = lifetimes::input();

        let cases = [
            (
                Case::Ident(Some(&reserved_ident)),
                Action::Forbid(ParseError::UseOfReservedIdent),
            ),
            (
                Case::Lifetime(Some(&reserved_lifetime)),
                Action::Forbid(ParseError::UseOfReservedLifetime),
            ),
            (
                Case::Lifetime(None),
                Action::Forbid(ParseError::NoGenericLifetimeSupport),
            ),
        ];

        let outcome = sanitizer.sanitize(&cases);

        if let Err(err) = outcome.check() {
            errors.subsume(err);
        }

        if outcome.count(&Case::Ident(Some(&reserved_ident))) > 0 {
            // fail-fast due to reuse of the self ident for code generation
            return Err(errors);
        }

        let type_ = infallible!({ parse2(sanitizer.to_token_stream()) });

        let mut methods = vec![];

        for item in &input.item.items {
            if let ImplItem::Fn(method) = item {
                match LogicMethod::try_from(LogicMethodImplInput {
                    type_: &type_,
                    item: method,
                }) {
                    Ok(LogicMethod::Public(method)) => methods.push(method),
                    Ok(LogicMethod::Private) => {}
                    Err(err) => errors.combine(&err),
                }
            }
        }

        errors.check()?;

        Ok(Self {
            methods,
            orig: input.item,
        })
    }
}
